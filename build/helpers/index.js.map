{"version":3,"file":"index.js","sourceRoot":"/","sources":["helpers/index.ts"],"names":[],"mappings":";;;AACO,MAAM,2BAA2B,GAAG,KAAK,EAAE,EAChD,MAAM,EACN,OAAO,EACP,KAAK,EACL,EAAE,EACF,OAAO,EACP,UAAU,EACV,IAAI,GASL,EAAE,EAAE;IAEH,IAAI,OAAO,KAAK,CAAC,EAAE;QAEjB,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,GACpB,IAAI,CAAC,EAAE,CAAC,CAAC;QAGX,MAAM,UAAU,GAAG,UAAU,CAAC,MAAM,CAAC,CAAC;QAGtC,IAAI,IAAI,KAAK,UAAU,EAAE;YACvB,aAAa,CAAC,UAAU,CAAC,CAAC;SAC3B;QACD,IAAI,IAAI,KAAK,MAAM,EAAE;YACnB,YAAY,CAAC,UAAU,CAAC,CAAC;SAC1B;QAGD,OAAO,UAAU,CAAC,MAAM,CAAC,CAAC;QAK1B,OAAO;KACR;IAGD,KAAK,CAAC,MAAM,EAAE;QACZ,IAAI,EAAE,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC;QAC7B,MAAM,EAAE,MAAM;QACd,OAAO,EAAE,EAAE,aAAa,EAAE,UAAU,KAAK,EAAE,EAAE;KAC9C,CAAC,CAAC,KAAK,CAAC,GAAG,EAAE;QAEZ,UAAU,CAAC,GAAG,EAAE;YACd,IAAA,mCAA2B,EAAC;gBAC1B,MAAM;gBACN,OAAO,EAAE,OAAO,GAAG,CAAC;gBACpB,EAAE;gBACF,OAAO;gBACP,KAAK;gBACL,UAAU;gBACV,IAAI;aACL,CAAC,CAAC;QAEL,CAAC,EAAE,OAAO,IAAI,CAAC,GAAG,IAAI,CAAC,CAAC;IAC1B,CAAC,CAAC,CAAC;AACL,CAAC,CAAC;AA/DW,QAAA,2BAA2B,+BA+DtC;AAEK,MAAM,6BAA6B,GAAG,CAAC,EAC5C,IAAI,EACJ,cAAc,GAIf,EAAE,EAAE;IACH,MAAM,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;IAEjC,cAAc,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,EAAE;QAC/B,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC;YACjB,MAAM,IAAI,KAAK,CAAC,qCAAqC,KAAK,IAAI,CAAC,CAAC;IACpE,CAAC,CAAC,CAAC;AACL,CAAC,CAAC;AAbW,QAAA,6BAA6B,iCAaxC","sourcesContent":["// recursively retries request upto 3 times\nexport const exponentialBackOffSafeFetch = async ({\n  apiUrl,\n  payload,\n  token,\n  id,\n  attempt,\n  timeoutIds,\n  jobs,\n}: {\n  apiUrl: string;\n  payload: any;\n  token: string;\n  id: string;\n  attempt: number;\n  timeoutIds: { [key: string]: NodeJS.Timeout };\n  jobs: any;\n}) => {\n  // delete from queue after 3 attempts\n  if (attempt === 4) {\n    // get timer ID from current job\n    const { timeId, type }: { timeId: string; type: 'ONCE' | 'INTERVAL' } =\n      jobs[id];\n\n    // get timeout object from memory using timer ID\n    const timeObject = timeoutIds[timeId];\n\n    // clear timer so it doesnt run\n    if (type === 'INTERVAL') {\n      clearInterval(timeObject);\n    }\n    if (type === 'ONCE') {\n      clearTimeout(timeObject);\n    }\n\n    // delete timer from memory\n    delete timeoutIds[timeId];\n\n    // NOTE: we can't actually update redis because the job store might be different\n    // from when this is executed to when this was first created therefore we'd\n    // overwrite the current jobs with the old jobs (the ones present when first created this job)\n    return;\n  }\n\n  // runs and retries\n  fetch(apiUrl, {\n    body: JSON.stringify(payload),\n    method: 'POST',\n    headers: { Authorization: `Bearer ${token}` },\n  }).catch(() => {\n    // retry exponentially\n    setTimeout(() => {\n      exponentialBackOffSafeFetch({\n        apiUrl,\n        attempt: attempt + 1,\n        id,\n        payload,\n        token,\n        timeoutIds,\n        jobs,\n      });\n      // with an exponential backoff timer\n    }, attempt ** 2 * 1000);\n  });\n};\n\nexport const validateRequestBodyWithFields = ({\n  body,\n  requiredFields,\n}: {\n  body: string;\n  requiredFields: string[];\n}) => {\n  const payload = JSON.parse(body);\n\n  requiredFields.forEach((field) => {\n    if (!payload[field])\n      throw new Error(`Missing required body parameter: '${field}'.`);\n  });\n};\n"]}