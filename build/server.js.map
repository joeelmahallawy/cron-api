{"version":3,"file":"server.js","sourceRoot":"/","sources":["server.ts"],"names":[],"mappings":"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","sourcesContent":["import fetch from 'node-fetch';\nimport 'dotenv/config';\nimport crypto from 'crypto';\nimport fastify, { FastifyError } from 'fastify';\nimport fastifyRedis from '@fastify/redis';\nimport {\n  exponentialBackOffSafeFetch,\n  validateRequestBodyWithFields,\n} from './helpers';\n\nconst server = fastify({ logger: true, pluginTimeout: 15000 });\n\n// store timer objects in memory\nconst timeoutIds: { [key: string]: NodeJS.Timeout } = {};\n\nserver.register(fastifyRedis, { url: process.env.REDIS_URL });\n\nserver.get(`/createToken`, async (req, reply) => {\n  try {\n    const token = crypto.randomUUID();\n\n    const { redis } = server;\n\n    const set = await redis.set(token, JSON.stringify({}));\n\n    if (set === 'OK') return { token, success: true };\n  } catch (err) {\n    // @ts-expect-error\n    return reply.status(400).send({ success: false, error: err.message });\n  }\n});\n\nserver.post(`/once`, async (req, reply) => {\n  try {\n    //  first check if we have all the valid body parameters\n    validateRequestBodyWithFields({\n      body: req.body as string,\n      requiredFields: ['id', 'runAt', 'payload', 'apiUrl'],\n    });\n    // runAt should be UNIX timestamp (in milliseconds)\n    const { id, runAt, payload, apiUrl } = JSON.parse(req.body as string);\n    const { redis } = server;\n\n    const token = req.headers.authorization?.replace(`Bearer `, '');\n\n    // check if there's a token\n    if (!token)\n      return reply.status(401).send({\n        success: false,\n        error: `Token error: token was not found in the 'Authorization' header.`,\n      });\n\n    const jobsString = await redis.get(token);\n\n    // check if token points to jobs in the database\n    if (!jobsString) {\n      throw new Error(\n        `Invalid token: token doesn't exist or associated with any jobs.`\n      );\n    }\n\n    // ensure the given time didn't already pass\n    if (Date.now() > runAt)\n      throw new Error(\n        `Invalid date: can only run cron jobs in the future and the timestamp received has already passed.`\n      );\n\n    // turn `jobs` to object so we can insert job objects\n    const jobs = JSON.parse(jobsString);\n\n    // check if job ID already exists\n    if (jobs[id])\n      throw new Error(\n        `The 'id' parameter is already associated with another job, please pass in a unique ID.`\n      );\n\n    // measure delay of job\n    const timeFromNowInMilliseconds = runAt - Date.now();\n\n    // run after delay\n    const timerObject = setTimeout(() => {\n      exponentialBackOffSafeFetch({\n        apiUrl,\n        attempt: 1,\n        id,\n        payload,\n        token,\n        timeoutIds,\n        jobs,\n      });\n    }, timeFromNowInMilliseconds);\n\n    // create time ID to reference to and stop timer\n    const timeId = crypto.randomUUID();\n\n    // store timeout object in memory so we can cancel it later on\n    timeoutIds[timeId] = timerObject;\n\n    // insert job under user's job store\n    jobs[id] = { apiUrl, runAt, payload, timeId, type: 'ONCE' };\n\n    // write to redis\n    redis.set(token, JSON.stringify(jobs));\n\n    return { success: true };\n  } catch (err) {\n    // @ts-expect-error\n    return reply.status(400).send({ success: false, error: err.message });\n  }\n});\n\nserver.post(`/periodic`, async (req, reply) => {\n  try {\n    //  first check if we have all the right body parameters and throw error for missing parameters\n    validateRequestBodyWithFields({\n      body: req.body as string,\n      requiredFields: ['id', 'interval', 'payload', 'apiUrl'],\n    });\n\n    // interval should be in milliseconds\n    const { id, interval, payload, apiUrl } = JSON.parse(req.body as string);\n    const { redis } = server;\n    const token = req.headers.authorization?.replace(`Bearer `, '');\n\n    // check if there's a token\n    if (!token)\n      return reply.status(401).send({\n        success: false,\n        error: `Token error: missing required token from 'Authorization' header.`,\n      });\n\n    const jobsString = await redis.get(token);\n\n    // check if token points to jobs in the database\n    if (!jobsString) {\n      throw new Error(`Invalid token: token doesn't exist.`);\n    }\n\n    // turn `jobs` to object so we can insert job objects\n    const jobs = JSON.parse(jobsString);\n\n    // check if job ID already exists\n    if (jobs[id])\n      throw new Error(\n        `The ID received in is already associated with another job, please pass in a unique ID.`\n      );\n\n    if (isNaN(interval))\n      throw new Error(\n        `The 'interval' parameter that was received is not a valid UNIX timestamp. Please make sure to pass in a valid UNIX timestamp in milliseconds.`\n      );\n\n    // run for every interval\n    const timerObject = setInterval(() => {\n      exponentialBackOffSafeFetch({\n        apiUrl,\n        attempt: 1,\n        id,\n        payload,\n        token,\n        timeoutIds,\n        jobs,\n      });\n    }, interval);\n\n    // create time ID to reference to and stop timer\n    const timeId = crypto.randomUUID();\n\n    // store timeout object in memory so we can cancel it later on\n    timeoutIds[timeId] = timerObject;\n\n    // insert job under user's job store\n    jobs[id] = { apiUrl, interval, payload, timeId, type: 'INTERVAL' };\n\n    // write to redis\n    redis.set(token, JSON.stringify(jobs));\n\n    return { success: true };\n  } catch (err) {\n    // @ts-expect-error\n    return reply.status(400).send({ success: false, error: err.message });\n  }\n});\n\nserver.post(`/stop`, async (req, reply) => {\n  try {\n    // get token and reject if not passed\n    const token = req.headers.authorization?.replace('Bearer ', '');\n    if (!token)\n      throw new Error(\n        `Token error: missing required token from 'Authorization' header.`\n      );\n\n    const { id } = JSON.parse(req.body as string);\n\n    // get job ID and reject if not passed in\n    if (!id) {\n      throw new Error(`Missing required body parameter: 'id'.`);\n    }\n\n    // get job store and reject if token doesn't exist\n    const jobStore = await server.redis.get(token);\n\n    if (!jobStore) throw new Error(`Invalid token: token doesn't exist.`);\n\n    // get jobs associated with token\n    const jobs = JSON.parse(jobStore);\n\n    // get job by ID and reject if job doesn't exist\n    const job: {\n      apiUrl: string;\n      runAt: string;\n      payload: string;\n      timeId: string;\n      type: 'ONCE' | 'INTERVAL';\n    } = jobs[id];\n\n    if (!job)\n      throw new Error(\n        `The 'id' received doesn't exist and isn't associated with any job.`\n      );\n\n    // get timeout ID from job\n    const { timeId } = job;\n    // get Node.js timer object from memory using timeout ID\n    const timeoutObject = timeoutIds[timeId];\n\n    // cancel timeout or interval so it doesn't run\n    if (job.type === 'ONCE') clearTimeout(timeoutObject);\n    else clearInterval(timeoutObject);\n\n    //  delete job from job store\n    delete jobs[id];\n\n    // delete timer from memory\n    delete timeoutIds[timeId];\n\n    // and update the job store\n    server.redis.set(token, JSON.stringify(jobs));\n\n    return reply.send({ success: true });\n  } catch (err) {\n    // @ts-expect-error\n    return reply.status(400).send({ success: false, error: err.message });\n  }\n});\n\n// @ts-expect-error\nserver.listen({ port: process.env.PORT || 4000, host: '0.0.0.0' });\n"]}